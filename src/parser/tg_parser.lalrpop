grammar;

use std::collections::HashMap;
use crate::temporal_graphs::{TemporalGraph, NodeAttr, Edge, Node};
use crate::parser::{ParsedData, ParsedLine};

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};
 
pub NodeAttr: NodeAttr = {
    "label" "(" <l:Label> ")" => NodeAttr::Label(l),
    "owner" "(" <b:Bool> ")" => NodeAttr::Owner(b),
};

pub NodeAttrList = Comma<NodeAttr>;



EdgeAttr: (String,String) = {
    "available" "(" <f:Formula> ")" =>  ("available".to_string(),f), // TODO: parse formula
    "label" "(" <Label> ")" =>  ("label".to_string(),<>),
};

EdgeAttrList = Comma<EdgeAttr>;
 
 
Id: String = {
    <s:r#"[A-Za-z0-9_]+"#> => s.to_string()
};






Bool: bool = {
    "0" => false,
    "1" => true,
};

Label: String = {
    r#""([^"\\]|\\.)*""# => String::from(&<>[1..<>.len()-1]),
};

Formula: String = {
    r#"[A-Za-z0-9_]+"# => <>.to_string()
};




pub Lines: ParsedData = {
    <l:Line*> => {
        let mut nodes = Vec::new();
        let mut edges = Vec::new();
        for item in l {
            match item {
                ParsedLine::Node(id, attrs) => nodes.push((id, attrs)),
                ParsedLine::Edge(from, to, attr) => edges.push((from, to,  attr)),
                ParsedLine::Empty => {}
            }
        }
        ParsedData { nodes, edges }
    }
};

CommentOrEmptyLine: () = {
    r#"[\s]*"# => (),
    r#"[\s]*#.*"# => (),
};



pub Line: ParsedLine = {
    CommentOrEmptyLine => ParsedLine::Empty,
    "node" <id:Id> ":" <attrs:NodeAttrList> => ParsedLine::Node(id, attrs),
    "node" <id:Id> => ParsedLine::Node(id.clone(), vec![]),

    "edge" <from:Id> "->" <to:Id> <props_string:(":" <EdgeAttrList>)?>
    => {
        let attrs = props_string.unwrap_or(vec![]);
        ParsedLine::Edge(from, to, attrs)
    }
};




pub TemporalGraph: TemporalGraph = {
    <l:Line*> => {
        // first collect all nodes and edges
        let mut node_lines = Vec::new();
        
        let mut edge_lines = Vec::new();
        for item in l {
            match item {
                ParsedLine::Node(_,_) => node_lines.push(item),
                ParsedLine::Edge(_,_,_) => edge_lines.push(item),
                ParsedLine::Empty => {},
            }
        }

        // Map string node IDs to indices
        let mut id_map = HashMap::new();
        let mut node_attrs: HashMap<Node, HashMap<String,NodeAttr>> = HashMap::new();
        let mut next_idx = 0;


        for item in &node_lines {
            if let ParsedLine::Node(id, attrs) = item {
                let idx = *id_map.entry(id.clone()).or_insert_with(|| {
                    let i = next_idx;
                    next_idx += 1;
                    i
                });

                let mut attr_map = HashMap::<String, NodeAttr>::new();

                for a in attrs {
                    match a {
                        NodeAttr::Owner(_) => {attr_map.insert("owner".to_string(), a.clone());}
                        NodeAttr::Label(_) => {attr_map.insert("label".to_string(), a.clone());}
                    }
                }
                node_attrs.insert(idx,attr_map);
            }
        }

        let node_count = next_idx;

        let mut edges = Vec::new();

        for item in &edge_lines {
            if let ParsedLine::Edge(from_id, to_id, attr) = item {
                let from = *id_map.get(from_id).unwrap();
                let to = *id_map.get(to_id).unwrap();
                let available_at = |_: usize| true;
                edges.push(Edge::new(from, to, available_at));
            }
        }

        TemporalGraph::new(
            node_count,
            node_attrs,
            edges,
        )
    },
 };
