grammar;

use crate::temporal_graphs::TemporalGraph;
use crate::parser::{ParsedLine, NodeAttr, EdgeAttr, temporal_graph_from_lines};

use crate::parser::formula::FormulaParser;


// declare precedences for the lexer
match {
    // skip whitespaces
    r"\s*" => { },                  


    // C-style comments
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`

    // anything else
    r#"[A-Za-z]+[A-Za-z0-9_]*"# => id_token,
    r"-?[0-9]+" => int_token,
    r#""([^"\\]|\\.)*""# => string_token,
    _
}


// Node ID: nonempty string starting with a letter
ID: String = {
    id_token => <>.to_string()
};

QuotedString: String = {
    string_token => String::from(&<>[1..<>.len()-1]),
};

INT: i64 = <s:int_token> => s.parse::<i64>().unwrap();



// Helper: a comma-separated list of Ts
Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};


// Node attributes, e.g. name="v0", player=0
NodeAttr: NodeAttr = {
    "name" "=" <l:QuotedString> => NodeAttr::Label(l),
    "player" "=" <i:INT> => NodeAttr::Owner(i%2==0),
};

// Lists of node and edge attributes
NodeAttrList = Comma<NodeAttr>;


// Edge attributes, so far only times
EdgeAttr: EdgeAttr = {
    "times" "=" <f:QuotedString> => EdgeAttr::Formula(FormulaParser::new().parse(&f).unwrap()),
};

// Lists of node and edge attributes
EdgeAttrList = Comma<EdgeAttr>;



// List of Node IDs
pub NIDList = Comma<ID>;


pub Line: ParsedLine = {
    <id:ID> "[" <attrs:NodeAttrList> "]" ";" => ParsedLine::Node(id, attrs),
    <from:ID> "->" <to:ID> "[" <attrs:EdgeAttrList> "]" ";" => ParsedLine::Edge(from, to, attrs),
};


// The main parser for tg-files.
//The logic is moved into a helper method that takes parsed lines
// and turns it into a TemporalGraph.
pub TemporalGraph: TemporalGraph = {
    "digraph" <name:ID> "{" <l:Line*> "}" => temporal_graph_from_lines(l),
};
