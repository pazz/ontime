grammar;

use std::collections::HashMap;
use crate::temporal_graphs::{TemporalGraph, NodeAttr, Edge, Node};
use crate::parser::{ParsedLine,temporal_graph_from_lines};

// Some basic terms
Id: String = {
    <s:r#"[A-Za-z0-9_]+"#> => s.to_string()
};

Bool: bool = {
    "0" => false,
    "1" => true,
};

Label: String = {
    r#""([^"\\]|\\.)*""# => String::from(&<>[1..<>.len()-1]),
};

Formula: String = {
    r#"[A-Za-z0-9_]+"# => <>.to_string()
};



 
// Node attributes, e.g. "owner(0)"
NodeAttr: NodeAttr = {
    "label" "(" <l:Label> ")" => NodeAttr::Label(l),
    "owner" "(" <b:Bool> ")" => NodeAttr::Owner(b),
};

// Edge attributes
EdgeAttr: (String,String) = {
    "available" "(" <f:Formula> ")" =>  ("available".to_string(),f), // TODO: parse formula
    "label" "(" <Label> ")" =>  ("label".to_string(),<>),
};


// Helper: a comma-separated list of Ts
Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};


// Lists of node and edge attributes
EdgeAttrList = Comma<EdgeAttr>;
NodeAttrList = Comma<NodeAttr>;



CommentOrEmptyLine: () = {
    r#"[\s]*"# => (),
    r#"[\s]*#.*"# => (),
};

pub Line: ParsedLine = {
    CommentOrEmptyLine => ParsedLine::Empty,
    "node" <id:Id> ":" <attrs:NodeAttrList> => ParsedLine::Node(id, attrs),
    "node" <id:Id> => ParsedLine::Node(id, vec![]),
    "edge" <from:Id> "->" <to:Id> <props:(":" <EdgeAttrList>)?> => ParsedLine::Edge(from, to, props.unwrap_or(vec![])),
};


// The main parser for tg-files.
//The logic is moved into a helper method that takes parsed lines
// and turns it into a TemporalGraph.
pub TemporalGraph: TemporalGraph = {
    <l:Line*> => temporal_graph_from_lines(l),
};
